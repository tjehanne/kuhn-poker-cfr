<!DOCTYPE html>
<html>
<head>
    <title>Hawk-Dove Simulation</title>
    <style>
        body { margin:0; font-family:sans-serif; display:flex; height:100vh; overflow:hidden; }
        #left-panel { flex:2; display:flex; flex-direction:row; align-items:flex-start; justify-content:flex-start; padding:10px; }
        canvas { border:1px solid black; background:#f9f9f9; margin:10px; }
        #controls { flex:1; display:flex; flex-direction:column; justify-content:flex-start; margin-left:10px; }
        label { margin-bottom:10px; }
        input[type=range] { width:150px; }
        button { margin-top:10px; padding:5px 10px; margin-bottom:5px; }
    </style>
</head>
<body>
<div id="left-panel">
    <canvas id="board" width="600" height="600"></canvas>
    <canvas id="chart" width="400" height="600"></canvas>
</div>
<div id="controls">
    <h2>Simulation Controls</h2>
    <label>Hawks: <span id="hawksVal">10</span>
        <input type="range" id="hawksSlider" min="0" max="50" value="10">
    </label>
    <label>Doves: <span id="dovesVal">10</span>
        <input type="range" id="dovesSlider" min="0" max="50" value="10">
    </label>
    <button id="startBtn">Start</button>
    <button id="stopBtn">Stop</button>
    <button id="resetBtn">Reset</button>
</div>

<script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
<script>
    const boardCanvas = document.getElementById('board');
    const ctx = boardCanvas.getContext('2d');
    const chartCanvas = document.getElementById('chart');

    const chart = new Chart(chartCanvas, {
        type:'line',
        data:{labels:[], datasets:[
                {label:'Hawks',borderColor:'red',data:[],fill:false},
                {label:'Doves',borderColor:'blue',data:[],fill:false}
            ]},
        options:{responsive:false, plugins:{legend:{position:'top'}}, scales:{x:{title:{display:true,text:'Day'}},y:{title:{display:true,text:'Population'}}}}
    });

    let creatures=[], foods=[], day=0, animating=false, intervalId=null, nextCreatureId=0;
    const radius=280, center={x:300,y:300};

    const hawksSlider=document.getElementById('hawksSlider');
    const dovesSlider=document.getElementById('dovesSlider');
    const hawksVal=document.getElementById('hawksVal');
    const dovesVal=document.getElementById('dovesVal');
    const startBtn=document.getElementById('startBtn');
    const stopBtn=document.getElementById('stopBtn');
    const resetBtn=document.getElementById('resetBtn');

    hawksSlider.oninput = ()=>{hawksVal.textContent = hawksSlider.value; resetCreaturesAndChart();}
    dovesSlider.oninput = ()=>{dovesVal.textContent = dovesSlider.value; resetCreaturesAndChart();}

    function initCreatures(hawks,doves){
        creatures=[];
        const total=parseInt(hawks)+parseInt(doves);
        for(let i=0;i<total;i++){
            const angle=(2*Math.PI*i)/total;
            const type=i<hawks?"HAWK":"DOVE";
            creatures.push({
                id: nextCreatureId++,
                type,
                angle,
                x:center.x+radius*Math.cos(angle),
                y:center.y+radius*Math.sin(angle),
                startX:center.x+radius*Math.cos(angle),
                startY:center.y+radius*Math.sin(angle),
                target:null,
                state:"atPerimeter",
                food:0,
                alpha:1
            });
        }
        draw();
    }

    function resetCreaturesAndChart(){
        day=0;
        initCreatures(hawksSlider.value, dovesSlider.value);
        chart.data.labels=[day];
        chart.data.datasets[0].data=[creatures.filter(c=>c.type==="HAWK").length];
        chart.data.datasets[1].data=[creatures.filter(c=>c.type==="DOVE").length];
        chart.update();
    }

    function generateFoodPairsStructured() {
        foods = [];
        const circles = [
            {radius:100, pairs:4},
            {radius:150, pairs:6},
            {radius:200, pairs:8}
        ];
        const offset = 10;

        circles.forEach(circle => {
            const {radius, pairs} = circle;
            for (let i=0; i<pairs; i++) {
                const angle = (2 * Math.PI / pairs) * i;
                const xCenter = center.x + radius * Math.cos(angle);
                const yCenter = center.y + radius * Math.sin(angle);
                const x1 = xCenter + offset * Math.cos(angle + Math.PI/2);
                const y1 = yCenter + offset * Math.sin(angle + Math.PI/2);
                const x2 = xCenter + offset * Math.cos(angle - Math.PI/2);
                const y2 = yCenter + offset * Math.sin(angle - Math.PI/2);
                foods.push([{x:x1,y:y1,eaten:false, angle, r:radius}, {x:x2,y:y2,eaten:false, angle, r:radius}]);
            }
        });
    }

    function draw(){
        ctx.clearRect(0,0,boardCanvas.width,boardCanvas.height);
        ctx.beginPath();
        ctx.arc(center.x,center.y,radius,0,2*Math.PI);
        ctx.stroke();

        foods.forEach(pair=>{
            pair.forEach(f=>{
                if(!f.eaten){
                    ctx.beginPath();
                    ctx.arc(f.x,f.y,7,0,2*Math.PI);
                    ctx.fillStyle='green';
                    ctx.fill();
                }
            });
        });

        creatures.forEach(c=>{
            ctx.beginPath();
            ctx.arc(c.x,c.y,8,0,2*Math.PI);
            ctx.fillStyle=c.type==="HAWK"?'rgba(255,0,0,'+c.alpha+')':'rgba(0,0,255,'+c.alpha+')';
            ctx.fill();
        });
    }

    function moveTowards(obj,target,speed){
        const dx=target.x-obj.x, dy=target.y-obj.y;
        const dist=Math.sqrt(dx*dx+dy*dy);
        if(dist<speed){ obj.x=target.x; obj.y=target.y; return true;}
        obj.x+=dx/dist*speed; obj.y+=dy/dist*speed; return false;
    }

    function assignTargetsToFoodStructured(){
        creatures.forEach(c => {
            const pair = foods[Math.floor(Math.random()*foods.length)];
            const xCenter = (pair[0].x + pair[1].x)/2;
            const yCenter = (pair[0].y + pair[1].y)/2;
            const angle = Math.atan2(center.y - yCenter, center.x - xCenter);

            if(!pair.occupiedOffsets) pair.occupiedOffsets = [];
            let possibleOffsets = [-15,15].filter(off => !pair.occupiedOffsets.includes(off));
            if(possibleOffsets.length === 0) possibleOffsets = [-15,15];
            const offset = possibleOffsets[Math.floor(Math.random()*possibleOffsets.length)];
            pair.occupiedOffsets.push(offset);

            const radiusAdjust = offset>0? -5:5;
            const target = { x: xCenter + (offset+radiusAdjust) * Math.cos(angle), y: yCenter + (offset+radiusAdjust) * Math.sin(angle), pair, offset };
            c.target = target;
            c.state = "toFood";
            c.food = 0;
        });
    }

    //gestion de la repartition de la nourriture
    function eatFood(creature){
        const pair = creature.target.pair;
        if(pair.every(f=>f.eaten)) return;
        const others=creatures.filter(c=>c!==creature && c.target && c.target.pair===pair);
        const other=others[0] || null;

        let foodTaken=0;
        if(!other){ foodTaken=2; }
        else if(creature.type==="DOVE" && other.type==="DOVE"){ foodTaken=1; if(other) other.food=1; }
        else if(creature.type==="HAWK" && other.type==="HAWK"){ foodTaken=1; creature.food=0; if(other) other.food=0; }
        else if(creature.type==="HAWK" && other.type==="DOVE"){ foodTaken=1.5; if(other) other.food=0.5; }
        else if(creature.type==="DOVE" && other.type==="HAWK"){ foodTaken=0.5; if(other) other.food=1.5; }

        creature.food=foodTaken;
        pair.forEach(f=>f.eaten=true);
    }

    // Appliquer mort/reproduction, enfants visibles
    function applyMortReproduction(){
        let survivors=[];
        let children=[];

        creatures.forEach(c=>{
            let survives=false, reproduce=false;

            if(c.food>=2){ survives=true; reproduce=true; }
            else if(c.food>=1.5){ survives=true; reproduce=Math.random()<0.5; }
            else if(c.food>=1) survives=true;
            else if(c.food>=0.5) reproduce=Math.random()<0.5;

            if(survives) survivors.push(c);

            if(reproduce){
                const child = {
                    ...c,
                    id: nextCreatureId++,
                    alpha: 1,      // visible dès le départ
                    x: c.x,        // superposé au parent
                    y: c.y,
                    startX: c.x,
                    startY: c.y
                };
                children.push(child);
            }
        });

        return [...survivors, ...children];
    }

    async function animateStep(state){
        return new Promise(resolve=>{
            const speed=4;
            function loop(){
                let done=true;
                creatures.forEach(c=>{
                    if(c.state===state && c.target){
                        if(!moveTowards(c,c.target,speed)) done=false;
                    }
                });
                draw();
                if(!done) requestAnimationFrame(loop);
                else resolve();
            }
            loop();
        });
    }

    // Glissement le long du cercle sans chevauchement
    async function animateEndOfDay(newCreatures){
        const total = newCreatures.length;

        // Trier par type pour garder Hawks et Doves groupés
        const hawks = newCreatures.filter(c => c.type === "HAWK");
        const doves = newCreatures.filter(c => c.type === "DOVE");

        // Position finale équidistante
        let positions = [];
        const stepAngle = 2 * Math.PI / total;
        let angleCursor = 0;

        function assignEquidistant(group){
            group.forEach(c => {
                c.targetAngle = angleCursor;
                c.angle = Math.atan2(c.y - center.y, c.x - center.x);
                c.alpha = 1;
                positions.push(c);
                angleCursor += stepAngle;
            });
        }

        assignEquidistant(hawks);
        assignEquidistant(doves);

        creatures = newCreatures.slice();

        return new Promise(resolve => {
            function loop(){
                let done = true;
                creatures.forEach(c => {
                    let diff = c.targetAngle - c.angle;
                    if(diff > Math.PI) diff -= 2*Math.PI;
                    else if(diff < -Math.PI) diff += 2*Math.PI;

                    if(Math.abs(diff) > 0.001){
                        c.angle += diff * 0.2; // vitesse de glissement
                        done = false;
                    }

                    // mise à jour position
                    c.x = center.x + radius * Math.cos(c.angle);
                    c.y = center.y + radius * Math.sin(c.angle);
                });

                draw();

                if(!done) requestAnimationFrame(loop);
                else{
                    creatures.forEach(c=>{
                        c.startX = c.x;
                        c.startY = c.y;
                        c.angle = c.targetAngle;
                    });
                    resolve();
                }
            }
            loop();
        });
    }

    function updateChart(){
        chart.data.labels.push(day);
        chart.data.datasets[0].data.push(creatures.filter(c=>c.type==="HAWK").length);
        chart.data.datasets[1].data.push(creatures.filter(c=>c.type==="DOVE").length);
        chart.update();
    }

    async function stepDay(){
        if(animating) return;
        animating=true;
        day++;

        generateFoodPairsStructured();
        assignTargetsToFoodStructured();
        await animateStep("toFood");
        creatures.forEach(c=>{if(c.state==="toFood") eatFood(c);});

        creatures.forEach(c=>{
            c.target={x:c.startX, y:c.startY};
            c.state="toPerimeter";
        });
        await animateStep("toPerimeter");

        const newCreatures = applyMortReproduction();
        await animateEndOfDay(newCreatures);

        updateChart();
        animating=false;
    }

    // Boutons
    startBtn.onclick = ()=>{ if(!intervalId) intervalId=setInterval(()=>stepDay(),3000); };
    stopBtn.onclick = ()=>{ if(intervalId){ clearInterval(intervalId); intervalId=null; } };
    resetBtn.onclick = ()=>{ if(intervalId){ clearInterval(intervalId); intervalId=null; } resetCreaturesAndChart(); };

    // Init jour 0
    window.onload = ()=>{ resetCreaturesAndChart(); }
</script>
</body>
</html>
